---
title: "p8105_hw2_al3851.Rmd"
output: github_document
---

```{r packages}

library(tidyverse)
library(p8105.datasets)

```

#Problem 1

##Initial Cleaning


```{r}

station_df = read_csv("./Data/NYC_Transit_Subway_Entrance_And_Exit_Data.csv") %>%
  janitor::clean_names() %>%
  select(line:entry, vending, ada) %>%
  mutate(vending = recode(vending, "YES" = TRUE, "NO" = FALSE)) %>%
  mutate(entry = recode(entry, "YES" = TRUE, "NO" = FALSE))


```

The data is still not tidy because the train line and route number are arranged in the wide format, since each route number is a variable name. However, after cleaning the names of the columns I selected only the needed columns, and within the mutate function, I used recode so that the "YES" "NO" charcter values of vending and entry would now be the logical TRUE FALSE. The data set has `r nrow(station_df)` rows which represent each entrance or exit to every station in NYC and the dataset has `r ncol(station_df)` variables which are `colnames(station_df)`. 


##ADA Compliance 

I am using distinct with the parameter .keep_all = TRUE to get a dataframe with just one row from each station.
The number of rows will tell me the number of distinct stations. The sum of the ada variable divided by the number of rows  will tell me te proportion that is compliant.

```{r}
distinct_station_df = station_df %>%
  distinct(line, station_name, .keep_all = TRUE)

n_stations = nrow(distinct_station_df)

compliant_percent = (sum(distinct_station_df$ada) / n_stations)*10

```

There are 465 distinct stations and `r compliant_percent` percent of the stations are ADA compliant.  

##A Train 

I am making route number a variable by using the gather function. I don't need the entries in the route_number column to start with route, so I am separating the entries at the end of the word route, and am deleting the column just consisting of the word "route". The I am filtering for stations that have an A train route and am further filtering to choose only stations that are ada compliant. 

```{r}
distinct_a_df = distinct_station_df %>%
  gather(key = route_number, value = route_name, route1:route11) %>%
  separate(route_number, sep = "route", into = c("remove1", "route")) %>%
  select(-remove1) %>%
  filter(route_name == "A")

distinct_a_ada_df = distinct_a_df %>%
  filter(ada == TRUE)

```


`r nrow(distinct_a_df)` stations serve the A train 

and `r nrow(distinct_a_ada_df)` of these stations are ada compliant

#Problem 2 

##Clean Mr. Trash

Along with rounding the number of sports balls to integers and filtering out totals, I will fill in the missing years by extracting the year from the date. 

```{r}
library(cellranger)
library(readxl)
library(lubridate)
library(dplyr)


mr_trash_df = read_excel("./Data/HealthyHarborWaterWheelTotals2018-7-28.xlsx", 
                         skip = 1, 
                         sheet = 1, 
                         range = cell_cols("A:N")) %>% 
  janitor::clean_names() %>%
  filter(!is.na(dumpster)) %>%
  filter(!grepl("Total", month)) %>%
  mutate(sports_balls = round(sports_balls, digits = 0)) %>%
  mutate(sports_balls = as.integer(sports_balls)) %>%
  mutate(year = ifelse(!is.na(year), year, year(date)))
  


  

```




##Read in Precipitation


```{r}

precipitation_2017_df = read_excel("./Data/HealthyHarborWaterWheelTotals2018-7-28.xlsx", skip = 1, sheet = 3, range = "A2:B10") %>%
  janitor::clean_names() %>%
  mutate(year = 2017)


precipitation_2016_df = read_excel("./Data/HealthyHarborWaterWheelTotals2017-9-26.xlsx", skip = 1, sheet = 4, range = "A2:B14") %>%
  janitor::clean_names() %>%
  mutate( year = 2016)

precipitation_combined_df = bind_rows(precipitation_2017_df, precipitation_2016_df) %>%
  mutate(month = month.name[month])
  

```



I am filtering by year to isolate the months with the highest total rainfall each year. 
I am also creating dataframes so I can report median number of items each year along with the months that contain the maximum trash collected

```{r}

max_month_df = precipitation_combined_df %>%
  group_by(year) %>%
  filter(total == max(total)) %>%
  
  
max_month_2016_df = max_month %>%
  filter(year == 2016) 
  

  

mr_trash_2016_df = mr_trash_df %>%
  filter(year == 2016)


mr_trash_2016_totals = mr_trash_df %>%
  filter(year == 2016) %>%
  group_by(month) %>%
  summarise(sum(weight_tons)) %>%
  rename(sum_trash = `sum(weight_tons)`)

```



The unique identifyer in the precipitation dataset is month and year combined. The precipitation dataset provides data for `r nrow(precipitation_combined_df)` months. 

The total rainfall in 2016 was `r sum(precipitation_2016_df$total)` and the month with the maximum rainfall in 2016 was `r max_month_2016_df$month` with a total of `r max_month_2016_df$total` inches of rain. 

In 2017, the total amount of rain up until August was `r sum(precipitation_2016_df$total)`.

In the Mr. Trash dataset, the column named dumpster is the unique identifyer.The Mr Trash dataset provides data for `r nrow(mr_trash_df)` dumpsters and for each dumpster provides data for `r ncol(mr_trash_df) -1` variables.  

The median number of  sports balls in a dumpster in 2016 was `r median(mr_trash_2016_df$sports_balls)` In 2016 the month with the highest trash weight collected was `r mr_trash_2016_totals[which(mr_trash_2016_totals$sum_trash== max(mr_trash_2016_totals$sum_trash)), "month"]` coinciding with the month with the highest rainfall.  


##Problem 3

Formatting the brfss data. I am changing locationabbr to state (including washington dc)because it is more desriptive. Then I am selecting by writing in the columns I will not include and am using the spread function to make the type of response a column. 


```{r}

brfss_df = brfss_smart2010 %>%
  janitor::clean_names() %>%
  rename(proportion = data_value, state = locationabbr) %>%
  filter(topic == "Overall Health") %>%
  select(-class, -topic, -question, -sample_size, -c(confidence_limit_low:geo_location)) %>%
  spread(key = response, value = proportion) %>%
  janitor::clean_names() %>%
  mutate(excellent_or_very_good = excellent + very_good)






```

##Summary of Locations

```{r}

distinct_locations = unique(brfss_df$locationdesc)

distinct_states = unique(brfss_df$state)
length(distinct_states)

most_observed_state_df = brfss_df %>%
  group_by(state) %>%
  summarise( n = n()) %>%
  filter(n == max(n))

```


There are `r length(distinct_locations)` distinct locations and all the states are represented including Washington DC. The state with the most observations is `r most_observed_state_df$state`.


## Excellence 

I am filtering to just get rows where 

```{r}

brfss_excellent_2002 = brfss_df %>%
  filter(year == 2002) 
  
  
brfss_excellent_median = brfss_excellent_2002 %>%
  summarise(median(excellent, na.rm = TRUE))

ggplot(brfss_excellent_2002, aes(x = excellent)) + 
  geom_histogram() +
  labs(title = "Proportion of Excellent Overall Health Scores in 2002",
       x = "proportion excellent")

brfss_df %>%
  filter(locationdesc %in% c("NY - New York County", "NY - Queens County")) %>%
  ggplot(aes(x = year, y = excellent, color = locationdesc)) + 
  geom_point() +
  labs(title = "Excellent Response Proportions From 2002 to 2010", 
       y = "proportion excellent")

  

```

The median of the excellent responses in 2002 was `r brfss_excellent_median`












